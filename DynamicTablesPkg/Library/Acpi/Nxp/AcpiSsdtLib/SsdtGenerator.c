/** @file
  SSDT Table Generator/FixUP

  Copyright (c) 2020, Puresoftware Limited. All rights reserved.
  SPDX-License-Identifier: BSD-2-Clause-Patent
**/
#include <Library/AcpiLib.h>
#include <Library/BaseLib.h>
#include <Library/BaseMemoryLib.h>
#include <Library/DebugLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Protocol/AcpiTable.h>

// Module specific include files.
#include <AcpiTableGenerator.h>
#include <ConfigurationManagerObject.h>
#include <ConfigurationManagerHelper.h>
#include <Library/AmlLib/AmlLib.h>
#include <Library/TableHelperLib.h>
#include <Protocol/ConfigurationManagerProtocol.h>

// AML Code Include files generated by iASL Compiler
#include <Dsdt.hex>

/** This macro expands to a function that retrieves the SSDT
    Information from the Configuration Manager.
*/
GET_OBJECT_LIST (
    EObjNameSpaceArm,
    EArmObjSsdtFixupInfo,
    CM_ARM_SSDT_FIXUP_INFO
    );

/** Free any resources allocated for constructing a SSDT table.

    @param [in]      This           Pointer to the table generator.
    @param [in]      AcpiTableInfo  Pointer to the ACPI Table Info.
    @param [in]      CfgMgrProtocol Pointer to the Configuration Manager
    @param [in, out] Table          Pointer to the ACPI Table.

    @retval EFI_SUCCESS             The resources were freed successfully.
    @retval EFI_INVALID_PARAMETER   The table pointer is NULL or invalid.
**/
STATIC
EFI_STATUS
FreeSsdtTableResources (
    IN      CONST ACPI_TABLE_GENERATOR                  * CONST This,
    IN      CONST CM_STD_OBJ_ACPI_TABLE_INFO            * CONST AcpiTableInfo,
    IN      CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL  * CONST CfgMgrProtocol,
    IN OUT        EFI_ACPI_DESCRIPTION_HEADER          ** CONST Table
    )
{
  ASSERT (This != NULL);
  ASSERT (AcpiTableInfo != NULL);
  ASSERT (CfgMgrProtocol != NULL);
  ASSERT (AcpiTableInfo->TableGeneratorId == This->GeneratorID);

  if ((Table == NULL) || (*Table == NULL)) {
    DEBUG ((DEBUG_ERROR, "ERROR: SSDT: Invalid Table Pointer\n"));
    ASSERT ((Table != NULL) && (*Table != NULL));
    return EFI_INVALID_PARAMETER;
  }

  // Free the table list.
  FreePool (*Table);
  *Table = NULL;
  return EFI_SUCCESS;
}

/** Fixup SSDT table.
    For each template value:
     - find the node to update;
     - update the value.
  @param  [in]  RootNodeHandle    Pointer to the root of the AML tree.
  @param  [in]  SsdtFixupInfo     Pointer to a SsdtFixup structure.
  @param  [out] Table             On return, hold the serialized
                                  definition block.

  @retval  EFI_SUCCESS            The function completed successfully.
  @retval  EFI_INVALID_PARAMETER  Invalid parameter.
  @retval  EFI_NOT_FOUND          Could not find information.
  @retval  EFI_OUT_OF_RESOURCES   Out of resources.
**/
STATIC
EFI_STATUS
EFIAPI
FixupSsdtInfo (
    IN  AML_ROOT_NODE_HANDLE              RootNodeHandle,
    IN  CM_ARM_SSDT_FIXUP_INFO          * SsdtFixupInfo,
    OUT EFI_ACPI_DESCRIPTION_HEADER    ** Table
    )
{
  EFI_STATUS                Status = EFI_SUCCESS;
  AML_OBJECT_NODE_HANDLE    NameOpCrsNode;
  AML_DATA_NODE_HANDLE      InterruptRdNode;

  // Get the _CRS object defined by the "Name ()" statement.
  Status = AmlFindNode (
            RootNodeHandle,
            "\\_SB.MDI0.PHY4._CRS",
            &NameOpCrsNode
            );
  if (EFI_ERROR (Status)) {
    DEBUG ((
          DEBUG_ERROR,
          "ERROR: FixupSsdtInfo: Failed to find _CRS Node Handle."
          " Status = %r\n",
          Status
          ));
    goto error_handle;
  }

  // Get the first Rd node in the "_CRS" object.
  Status = AmlNameOpCrsGetFirstRdNode (NameOpCrsNode, &InterruptRdNode);
  if (EFI_ERROR (Status)) {
    DEBUG ((
          DEBUG_ERROR,
          "ERROR: FixupSsdtInfo: Failed to get Interrupt node from _CRS Node Handle."
          " Status = %r\n",
          Status
          ));
    goto error_handle;
  }

  // Update the interrupt number.
  Status = AmlUpdateRdInterrupt (InterruptRdNode,SsdtFixupInfo->Interrupt);
  if (EFI_ERROR (Status)) {
    DEBUG ((
          DEBUG_ERROR,
          "ERROR: FixupSsdtInfo: Failed to update Interrupt node of _CRS Node Handle."
          " Status = %r\n",
          Status
          ));
    goto error_handle;
  }

  Status = AmlSerializeDefinitionBlock (
            RootNodeHandle,
            Table
            );
  if (EFI_ERROR (Status)) {
    DEBUG ((
          DEBUG_ERROR,
          "ERROR: SSDT: Failed to Serialize SSDT Table Data."
          " Status = %r\n",
          Status
          ));
  }

error_handle:
  return Status;
}

/** Construct or Fixup the ACPI table using the ACPI table data provided.

  This function invokes the Configuration Manager protocol interface
  to get the required hardware information for generating the ACPI
  table.

  If this function allocates any resources then they must be freed
  in the FreeXXXXTableResources function.

  @param [in]  This           Pointer to the table generator.
  @param [in]  AcpiTableInfo  Pointer to the ACPI Table Info.
  @param [in]  CfgMgrProtocol Pointer to the Configuration Manager
                              Protocol Interface.
  @param [out] Table          Pointer to the constructed ACPI Table.

  @retval EFI_SUCCESS           Table generated successfully.
  @retval EFI_INVALID_PARAMETER A parameter is invalid.
**/
STATIC
EFI_STATUS
EFIAPI
BuildSsdtTable (
  IN  CONST ACPI_TABLE_GENERATOR                  * CONST This,
  IN  CONST CM_STD_OBJ_ACPI_TABLE_INFO            * CONST AcpiTableInfo,
  IN  CONST EDKII_CONFIGURATION_MANAGER_PROTOCOL  * CONST CfgMgrProtocol,
  OUT       EFI_ACPI_DESCRIPTION_HEADER          ** CONST Table
  )
{
  EFI_STATUS                        Status;
  EFI_STATUS                        Status1;
  EFI_ACPI_DESCRIPTION_HEADER     * SsdtTemplate;
  AML_ROOT_NODE_HANDLE              RootNodeHandle;
  CM_ARM_SSDT_FIXUP_INFO          * SsdtFixupInfo;

  // Get information about the h/w that need to be fixed
  Status = GetEArmObjSsdtFixupInfo (
      CfgMgrProtocol,
      CM_NULL_TOKEN,
      &SsdtFixupInfo,
      NULL
      );
  if (EFI_ERROR (Status)) {
    DEBUG ((
          DEBUG_ERROR,
          "ERROR: SSDT: Failed to get the Ssdt Fixup information."
          " Status = %r\n",
          Status
          ));
    goto error_handler;
  }

  SsdtTemplate = (EFI_ACPI_DESCRIPTION_HEADER*)&dsdt_aml_code;

  RootNodeHandle = NULL;
  Status = AmlParseDefinitionBlock (
      SsdtTemplate,
      &RootNodeHandle
      );
  if (EFI_ERROR (Status)) {
    DEBUG ((
          DEBUG_ERROR,
          "ERROR: SSDT: Failed to parse SSDT Template."
          " Status = %r\n",
          Status
          ));
    ASSERT (0);
    goto error_handler;
  }

  Status = FixupSsdtInfo (
      RootNodeHandle,
      SsdtFixupInfo,
      Table
      );
  if (EFI_ERROR (Status)) {
    DEBUG ((
          DEBUG_ERROR,
          "ERROR: SSDT: Failed to add SSDT Table."
          " Status = %r\n",
          Status
          ));
    ASSERT (0);
    goto error_handler;
  }

  goto exit_handler;

error_handler:
  // Free up the allocated resources in case of an error.
  FreeSsdtTableResources (
      This,
      AcpiTableInfo,
      CfgMgrProtocol,
      Table
      );

exit_handler:
  if (RootNodeHandle != NULL) {
    Status1 = AmlDeleteTree (RootNodeHandle);
    if (EFI_ERROR (Status1)) {
      DEBUG ((
            DEBUG_ERROR,
            "ERROR: SSDT: Failed to add SSDT table."
            " Status = %r\n",
            Status1
            ));
      ASSERT (0);
      // If Status was success but we failed to delete the AML Tree
      // return Status1 else return the original error code i.e. Status
      if (!EFI_ERROR (Status)) {
        return Status1;
      }
    }
  }

  return Status;
}

/** This macro defines the Raw Generator revision.
*/
#define SSDT_GENERATOR_REVISION CREATE_REVISION (1, 0)

/** The interface for the SSDT Table Generator.
*/
STATIC
CONST
ACPI_TABLE_GENERATOR SsdtTableGenerator = {
  // Generator ID
  CREATE_STD_ACPI_TABLE_GEN_ID (EStdAcpiTableIdSsdtFixup),
  // Generator Description
  L"ACPI.OEM.SSDT.GENERATOR",
  // ACPI Table Signature
  EFI_ACPI_6_3_SECONDARY_SYSTEM_DESCRIPTION_TABLE_SIGNATURE,
  // ACPI Table Revision - Unused
  0,
  // Minimum ACPI Table Revision - Unused
  0,
  // Creator ID
  TABLE_GENERATOR_CREATOR_ID_ARM,
  // Creator Revision
  SSDT_GENERATOR_REVISION,
  // Build Table function
  BuildSsdtTable,
  // Hence the Free Resource function.
  FreeSsdtTableResources,
  // Extended build function not needed
  NULL,
  // Extended build function not implemented by the generator.
  // Hence extended free resource function is not required.
  NULL
};

/** Register the Generator with the ACPI Table Factory.

  @param [in]  ImageHandle  The handle to the image.
  @param [in]  SystemTable  Pointer to the System Table.

  @retval EFI_SUCCESS           The Generator is registered.
  @retval EFI_INVALID_PARAMETER A parameter is invalid.
  @retval EFI_ALREADY_STARTED   The Generator for the Table ID
                                is already registered.
**/
EFI_STATUS
EFIAPI
AcpiSsdtLibConstructor (
  IN CONST EFI_HANDLE                ImageHandle,
  IN       EFI_SYSTEM_TABLE  * CONST SystemTable
  )
{
  EFI_STATUS  Status;
  Status = RegisterAcpiTableGenerator (&SsdtTableGenerator);
  DEBUG ((DEBUG_INFO, "RAW: Register Generator. Status = %r\n", Status));
  ASSERT_EFI_ERROR (Status);
  return Status;
}

/** Deregister the Generator from the ACPI Table Factory.

  @param [in]  ImageHandle  The handle to the image.
  @param [in]  SystemTable  Pointer to the System Table.

  @retval EFI_SUCCESS           The Generator is deregistered.
  @retval EFI_INVALID_PARAMETER A parameter is invalid.
  @retval EFI_NOT_FOUND         The Generator is not registered.
**/
EFI_STATUS
EFIAPI
AcpiSsdtLibDestructor (
  IN CONST EFI_HANDLE                ImageHandle,
  IN       EFI_SYSTEM_TABLE  * CONST SystemTable
  )
{
  EFI_STATUS  Status;
  Status = DeregisterAcpiTableGenerator (&SsdtTableGenerator);
  DEBUG ((DEBUG_INFO, "RAW: Deregister Generator. Status = %r\n", Status));
  ASSERT_EFI_ERROR (Status);
  return Status;
}
